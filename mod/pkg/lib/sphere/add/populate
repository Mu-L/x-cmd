# shellcheck shell=dash

# ___x_cmd_pkg_sphere_populate --sphere X --osarch <osarch> <pkg name> <version>

___x_cmd_pkg_sphere_populate(){
    local op="$1";
    case "$op" in
        done)       shift; ___x_cmd_pkg_sphere_populate_done "$@" ;;
        run)        shift; ___x_cmd_pkg_sphere_populate_run "$@" ;;
        *)          N=pkg M="sphere gc not such option '$op'" log:ret:64
    esac
}

___x_cmd_pkg_sphere_populate_done(){
    pkg:sphere:parse:args
    local x_treename=; ___x_cmd_pkg_treename_ "$name" "$version" "$osarch" || return
    local done_file="$___X_CMD_PKG_ROOT_SPHERE/$sphere_name/$x_treename/$name/$version/.x-cmd/donefile"
    [ -f "$done_file" ]
}

___x_cmd_pkg_sphere_populate_run(){
    pkg:sphere:parse:args

    local x_treename=; ___x_cmd_pkg_treename_ "$name" "$version" "$osarch" || return
    local tgt="$___X_CMD_PKG_ROOT_SPHERE/$sphere_name/$x_treename/$name/$version"
    local done_file="$___X_CMD_PKG_ROOT_SPHERE/$sphere_name/$x_treename/$name/$version/.x-cmd/donefile"

    ! [ -f "$done_file" ] || return 0

    pkg:info "Trying populate ==> '$name $version'"

    local download_file_ext=; local unpack=;
    ___x_cmd_pkg___attr "$name" "$version" "$osarch" "url.${___X_CMD_WEBSRC_REGION:-internet},download_file_ext,unpack" || return
    eval "local url=\$url_${___X_CMD_WEBSRC_REGION:-internet}"
    [ -z "$url" ] || {
        ___x_cmd_pkg_sphere_populate___unzip "$name" "$version" "$osarch" "$tgt" "$download_file_ext" "$unpack" || {
            pkg:error "Unzip $name $version $osarch failed"
            x rmrf "$tgt"
            return 1
        }
    }

    local script_path
    if ! script_path="$(___x_cmd_pkg___get_script_path "$name" "$version" "$osarch" populate)"; then
        pkg:error "Not found $name $version $osarch populate script file"
        x rmrf "$tgt"
        return 1
    fi

    if [ -f "$script_path" ]; then
        pkg:info "Running $script_path"
        pkg:debug --name "$name" --version "$version" --osarch "$osarch" --script_path "$script_path"

        local ___X_CMD_PKG___META_NAME="$name"
        local ___X_CMD_PKG___META_VERSION="$version"
        local ___X_CMD_PKG___META_OS="${osarch%%/*}"
        local ___X_CMD_PKG___META_ARCH="${osarch#*/}"
        local ___X_CMD_PKG___META_TGT="$tgt"
        local ___X_CMD_PKG___META_SPHERE_NAME="$sphere_name"
        {
            (
                trap 'printf "\r\n"; pkg:error "populate interrupted script"; return 130' INT
                . "$script_path"
            ) || {
                pkg:error "Source $script_path failed"
                x rmrf "$tgt"
                return 1
            }
        }
    fi

    pkg:debug "Add $name $version populate done file"
    ___x_cmd_pkg_sphere_populate___chmod "$name" "$version" "$osarch" "$tgt" || return
    x touch "$done_file"
}

# This is default
___x_cmd_pkg_sphere_populate___unzip(){
    local name="$1"; local version="$2"; local osarch="$3"; local tgt="$4";
    local download_file_ext="$5"; local unpack="$6";
    shift 6

    local os="${osarch%/*}";  local arch="${osarch#*/}";    local ball=

    [ -n "$unpack" ] || {
        pkg:debug "Skip unzip"
        return 0
    }

    if [ "$unpack" = "none" ] && [ -z "$download_file_ext" ]; then
        ball="$___X_CMD_PKG_DOWNLOAD_PATH/$name/$name.${os}.${arch}"
    else
        ball="$___X_CMD_PKG_DOWNLOAD_PATH/$name/${version}_${os}_${arch}.${download_file_ext}"
    fi

    [ -f "$ball" ] || N=pkg M="Not found zip package => $name $version" log:ret:1

    if [ "$unpack" = "folder" ]; then
        pkg:info  --ball "$ball" --target_dir "$tgt" "Unpacking"
        local unpack_dir="$___X_CMD_PKG_DOWNLOAD_PATH/$name/$version"
        ___X_CMD_ZUZ_QUIET=1 x uz "$ball" "$unpack_dir" || N=pkg M="Fail to unzip $ball" log:ret:1
        local x_=; x fsiter --dir01_ "$unpack_dir" || return
        pkg:debug --target_dir "$tgt" "Moving $unpack_dir/$x_"
        [ -d "$tgt" ] || x rmrf "$tgt"
        x mv "$unpack_dir/$x_" "$tgt" || return
        x rmrf "$unpack_dir"
    elif [ "$unpack" = "none" ]; then
        pkg:info  --ball "$ball" --target_dir "$tgt" "Copying"
        [ -d "$tgt" ] || x rmrf "$tgt"; x ensurefp "$tgt"
        x mkdirp "$tgt"
        x cp -f "$ball" "$tgt/"
    elif [ "$unpack" = "file" ]; then
        pkg:info  --ball "$ball" --target_dir "$tgt" "Unpacking"
        [ -d "$tgt" ] || x rmrf "$tgt"; x mkdirp "$tgt"
        ___X_CMD_ZUZ_QUIET=1 x uz "$ball" "$tgt"  || N=pkg M="Fail to unzip $ball" log:ret:1
    elif [ "$unpack" = "stationary" ]; then
        return 0
    else
        pkg:error "Yml of $name $version lacks of unpack key"
        return 1
    fi
}

___x_cmd_pkg_sphere_populate___chmod(){
    local name="$1"; local version="$2"; local osarch="$3"; local tgt="$4"
    shift 4
    local bin_path; local xbin_name;
    while read -r xbin_name; do
        [ -n "$xbin_name" ] || continue
        [ "${xbin_name##*:}" = "$name" ] || continue
        xbin_name="${xbin_name#*:}"
        xbin_name="${xbin_name%:*}"
        bin_path="$(___x_cmd_pkg_sphere_xbin_path "$xbin_name" "$version" "$osarch")"
        if  [ -f "$bin_path" ]; then
            chmod +x "$bin_path" || {
                pkg:error "Can't use chmod on $bin_path"
                x rmrf "$tgt"
                return 1
            }
        fi
    done < "$___X_CMD_PKG_METADATA_PATH/binmod.txt"
}

