# shellcheck    shell=dash

# TODO: Multiple thread
# TODO: Download Manager and more strategy
# TODO: Maybe using a P2P share connection for mirror downloading.

___x_cmd_pkg_download(){
    x:trace pkg/download
    case "$1" in
        -h|--help) ___x_cmd_pkg_help download; return 1 ;;
    esac

    local name="${1:?Provide pkg name}"
    local version="${2:-$(___x_cmd_pkg_default_version "$name")}"
    local osarch="${3:-$(___x_cmd_pkg_osarch)}"
    [ -n "$version" ] || {
        pkg:error "Not found candidate: $name;"
        pkg:error "Please use 'x pkg ll' or 'x pkg ls all <candidate>' to check available candidate and version"
        return 1
    }

    local url_list; url_list="$(___x_cmd_pkg___list "$name" "$version" "$osarch" "url.${___X_CMD_WEBSRC_REGION:-internet}" )" || return

    if [ -z "$url_list" ]; then
        pkg:error "Not found url for $name $version"
        pkg:error "Please use ' x pkg ll' or ' x pkg ls all <candidate> ' to check available candidate and version"
        return 1
    fi


    local download_file_ext; local md5 ; local sha1 ; local sha256; local sha512 ; local unpack
    ___x_cmd_pkg___attr "$name" "$version" "$osarch" "md5,sha1,sha256,sha512,download_file_ext,unpack"
    local url
    local head
    local os="${osarch%/*}";  local arch="${osarch#*/}"
    if [ "$unpack" = "none" ] && [ -z "$download_file_ext" ]; then
        local ball="$___X_CMD_PKG_DOWNLOAD_PATH/$name/$name.${os}.${arch}"
    else
        local ball="$___X_CMD_PKG_DOWNLOAD_PATH/$name/${version}_${os}_${arch}.$download_file_ext"
    fi

    mkdir -p "$___X_CMD_PKG_DOWNLOAD_PATH/$name" || {
        pkg:error "Create $___X_CMD_PKG_DOWNLOAD_PATH/$name failed" ; return 1
    }
    pkg:debug --Download name "$name" --version "$version" --url_list "$url_list" --ball "$ball"

    if [ -f "$ball" ]; then
        if ___x_cmd_pkg_download___check_hashsum "$ball" "$md5" "$sha1" "$sha256" "$sha512"; then
            pkg:debug "File already downloaded: $ball"
            return 0
        fi

        pkg:warn "File corrupted. Download the $ball again."
        x rmrf "$ball"
    fi
    (
    while read -r url; do
        # TODO: ___x_cmd_httpget support 302
        # ___x_cmd_httpget "$url" "$ball" || {
        pkg:info \
            -m "download $name=$version, thanks to the courtesy of ${url%/"${url#*//*/}"}" \
            --url "$url" --dest "$ball" --name "$name" --version "$version"
        # pkg:info "Download $name $version from $url to $ball"
        # TODO: x curl
        trap 'x pkg remove $name $version 2>/dev/null; printf "\r\n";  pkg:error "Download interrupted"; return 1;' INT
        head=$(curl -I "$url" | awk 'NR==1{ print $2}' )
        if [ "$head" -eq "200" ] || [ "$head" -eq "304" ] || [ "$head" -eq "302" ] || [ "$head" -eq "301" ]; then
            if ! curl --progress-bar --location --retry-max-time 10 --retry 0 "$url" --output "$ball"; then
                pkg:warn "Fail to download from $url"
                x rmrf "$ball"
                return 1
            fi
        else
            pkg:error "resource invalid: $url "
            return 1
        fi

        ! ___x_cmd_pkg_download___check_hashsum "$ball" "$md5" "$sha1" "$sha256" "$sha512" || return 0
        pkg:warn "File corrupted."
        x rmrf "$ball"
        return 1
    done <<A
$url_list
A
    )
}

___x_cmd_pkg_download___check_hashsum(){
    local filepath="${1:?Please priovide filepath}"
    local sha
    [ -z "$2" ]  ||   sha="$(___x_cmd_md5       "$filepath")"
    [ -z "$3" ]  ||   sha="$(___x_cmd_sha1      "$filepath")"
    [ -z "$4" ]  ||   sha="$(___x_cmd_sha256    "$filepath")"
    [ -z "$5" ]  ||   sha="$(___x_cmd_sha512    "$filepath")"

    [ "$sha" = "$2$3$4$5" ]  ||  {
        pkg:warn "Except: " "$2$3$4$5"  " equal to "  "${sha%% *}"
        return 1
    }
    return 0
}
