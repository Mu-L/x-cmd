# shellcheck shell=bash disable=SC2207,SC2034,SC1090,SC2120
# Section : adviser helper function: ls lsd seq get_result

___x_cmd_advise__ls(){ local IFS="$___X_CMD_ADVISE_IFS_INIT"; candidate_exec_arr=( $(x ls "$@") ); }

___x_cmd_advise__dir(){
    if [ -n "$ZSH_VERSION" ]; then
        _path_files -/
    elif command -v _filedir >/dev/null 2>&1; then
        _filedir -d
    else
        local localdir="${1:-${cur:-""}}"
        ___x_cmd_advise_set_nospace
        COMPREPLY=( $( compgen -S "/" -d "$localdir" 2>/dev/null) )
    fi
}

# TODO: same as _files
___x_cmd_advise__file(){
    if [ -n "$ZSH_VERSION" ]; then
        _files
    elif command -v _filedir >/dev/null 2>&1; then
        _filedir
    else
        local localdir="${1:-${cur:-""}}"
        ___x_cmd_advise_set_nospace
        COMPREPLY=( $(compgen -f "$localdir" 2>/dev/null) )
    fi
}

___x_cmd_advise_set_nospace(){
    if [ -n "$ZSH_VERSION" ]; then
        # TODO: ZSH complete no add space
        zstyle ':completion:*' add-space false
        # zstyle ':completion:*' insert-tab false
    elif command -v compopt >/dev/null 2>&1; then
        compopt -o nospace
    fi
}
# 1/10
___x_cmd_advise__seq(){
    local cur="${cur:-""}"
    candidate_exec_arr=( $(awk -v range="$1" -v cur="$cur" '
function inside(num, start, end, step){
    if ( (num < start) || (num > end) ) return 0
    if ( ( num - start ) % step == 0 ) return 1
    return 0
}

BEGIN{

    arr_len = split(range, arr, /\//)
    start = arr[1]
    end = arr[2]
    step = arr[3]
    if (step == "") step = 1

    num = (end - start + 1) / step
    if (num < 16) {
        for (i=start; i<=end; i=i+step) print i
        exit(0)
    }

    if (cur !~ /[0-9]+/) {
        exit(0)
    }

    if (inside(cur, start, end, step) == 1) print cur

    cur = cur * 10
    for (i=0; i<=9; ++i) {
        newnum = cur + i
        if (inside(newnum, start, end, step) == 1) print newnum
    }
}
' <<A
A
    ))

}

___x_cmd_advise__shift_comp_words(){
    if [ "$offset" -gt 0 ]; then
        local tmp=("${COMP_WORDS[@]:$offset}")
        COMP_WORDS=("${tmp[@]}")
        COMP_LINE="${tmp[*]}"
        COMP_CWORD="${#tmp[@]}"
        [ -n "$ZSH_VERSION" ] || COMP_CWORD=$((COMP_CWORD-1))
    fi

    module="${COMP_WORDS[0]}"
    [ -z "$ZSH_VERSION" ] || module="${COMP_WORDS[1]}"
}

___x_cmd_advise__comp_from_x(){
    local offset="${1:-$offset}"
    local module="$2"
    local COMP_WORDS=("${COMP_WORDS[@]}"); local COMP_LINE="$COMP_LINE"; local COMP_CWORD="$COMP_CWORD"
    [ -n "$module" ] || ___x_cmd_advise__shift_comp_words

    local x_=; ___x_cmd_advise___get_mod_advise_jso_ "$module"
    [ -f "$x_" ] || return 1

    [ "$___X_CMD_ADVISE_NOT_SUITABLE_XRC_MOD_LIST" != "${___X_CMD_ADVISE_NOT_SUITABLE_XRC_MOD_LIST#*${___X_CMD_UNSEENCHAR_NEWLINE}${module}${___X_CMD_UNSEENCHAR_NEWLINE}}" ] || \
    xrc "$module" # 2>/dev/null
    candidate_exec=
    eval "$(___x_cmd_advise_get_result_from_awk "$x_")" 2>/dev/null
    eval "$candidate_exec" 2>/dev/null
}

___x_cmd_advise__comp_from_xcmd(){
    local offset="${1:-$offset}"
    local module="$2"; local filepath
    local COMP_WORDS=("${COMP_WORDS[@]}"); local COMP_LINE="$COMP_LINE"; local COMP_CWORD="$COMP_CWORD"
    [ -n "$module" ] || ___x_cmd_advise__shift_comp_words

    filepath="$(___x_cmd_advise_man_which x-cmd "$module")"
    [ -f "$filepath" ] || return 1

    ___x_cmd_advise___load_xcmd_advise_util_file "$module"
    ___x_cmd_advise_man_load x-cmd "$module"
    local _candidate_arr=("${candidate_arr[@]}")
    candidate_exec=
    eval "$(___x_cmd_advise_get_result_from_awk "$filepath")" 2>/dev/null
    eval "$candidate_exec" 2>/dev/null
    _candidate_arr+=("${candidate_arr[@]}")
    local IFS="$___X_CMD_ADVISE_IFS_INIT"
    candidate_arr=( $( printf "%s\n" "${_candidate_arr[@]}" | awk -v FS=":" '!a[$1]++' ))
}

___x_cmd_advise__comp_from_origin(){
    local offset="${1:-$offset}"
    local module="$2"; local filepath
    local COMP_WORDS=("${COMP_WORDS[@]}"); local COMP_LINE="$COMP_LINE"; local COMP_CWORD="$COMP_CWORD"
    [ -n "$module" ] || ___x_cmd_advise__shift_comp_words
    local IFS=" $___X_CMD_UNSEENCHAR_NEWLINE"
    local x_=""
    # TODO: must have map from command to function name and script path
    if [ -n "$ZSH_VERSION" ]; then
        local words=( "${COMP_WORDS[@]}" )
        local CURRENT="$COMP_CWORD"
        ___x_cmd_advise_man_completion___getfile_ "$module"
        [ -f "$x_" ] || return
        . "$x_" 2>/dev/null 1>&2
    else
        ___x_cmd_advise_man_completion___getfile_ "$module"
        [ -f "$x_" ] || return
        . "$x_" 2>/dev/null 1>&2
        command -v "_$module" >/dev/null || return 1
        eval "_$module"
    fi
}

___x_cmd_advise__comp_from_xcmd_or_origin(){
    local offset="${1:-$offset}"
    local module="$2"
    local COMP_WORDS=("${COMP_WORDS[@]}"); local COMP_LINE="$COMP_LINE"; local COMP_CWORD="$COMP_CWORD"
    [ -n "$module" ] || ___x_cmd_advise__shift_comp_words

    ___x_cmd_advise__comp_from_xcmd 0 "$module" \
        || ___x_cmd_advise__comp_from_origin 0 "$module"
}

## EndSection
