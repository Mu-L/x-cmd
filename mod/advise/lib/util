# shellcheck shell=bash disable=SC2034,2206
___X_CMD_ADVISE_IFS_INIT="$___X_CMD_UNSEENCHAR_NEWLINE"
___x_cmd_advise_completer() {
    # Interesting ... Passing
    ___x_cmd_advise_run ""
}

# TODO:
___x_cmd_advise_update(){
    local name="$1"
    arg:init advise
    [ -n "$name" ] || M="Provide command name" arg:ret:64
    local x_=; ___x_cmd_advise_which_ "$1"
    if [ -f "$x_" ] && [ -z "$(find "$x_" -mtime -1)" ]; then
        ___x_cmd rmrf "$x_"
        ___x_cmd_advise_init "$name"
    fi
}

___X_CMD_ADVISE_MAX_ITEM=99
___x_cmd_advise_maxitem(){
    if [ "$#" -gt 0 ]; then
        ___X_CMD_ADVISE_MAX_ITEM="$(( $1 + 0 ))"
    fi
    printf "___X_CMD_ADVISE_MAX_ITEM=%s\n" "$___X_CMD_ADVISE_MAX_ITEM"
}

___x_cmd_advise_init(){
    local X_help_cmd; X_help_cmd='___x_cmd help -m advise init' help:arg-null:parse
    local name="${1}";  [ -n "$name" ] || N=advise M="Provide command name" log:ret:64
    local op="${2}"
    local alias_value="${3}"
    local filepath="$___X_CMD_ADVISE_TMPDIR/$name"

    ___x_cmd mkdirp "$___X_CMD_ADVISE_TMPDIR"

    if [ "-" = "$op" ]; then ___x_cmd_cmds_cat >"$filepath"
    elif [ -f "$op" ]; then
        { [ -f "$filepath" ] && [ "$filepath" -nt "$op" ] ; } || {
            advise:debug "Copy $op to $filepath"
            ___x_cmd_cmds_cp "$op" "$filepath"
        }
    else
        local x_=; ___x_cmd_advise___get_mod_advise_jso_ "$name" || N=advise M="advise init not found advise jso file of '$name'. [filepath=${op:-"$x_"}]" log:ret:64
        { [ -f "$filepath" ] && [ "$filepath" -nt "$x_" ] ; } || {
            advise:debug "Copy $x_ to $filepath"
            ___x_cmd_cmds_cp "$x_" "$filepath"
        }

        [ "$___X_CMD_ADVISE_NOT_SUITABLE_XRC_MOD_LIST" != "${___X_CMD_ADVISE_NOT_SUITABLE_XRC_MOD_LIST#*"${___X_CMD_UNSEENCHAR_NEWLINE}${name}${___X_CMD_UNSEENCHAR_NEWLINE}"}" ] || \
        xrc "$name"
    fi

    local comp_name="$name"
    local comp_func="___x_cmd_advise_completer"
    if [ -n "$alias_value" ]; then
        comp_func="___x_cmd_advise_completer_alias_$name"
        [ -z "$ZSH_VERSION" ] || comp_name="$alias_value"
        eval "$comp_func(){
            ___x_cmd_advise_run \"${alias_value}\"
        }"
    fi

    ___x_cmd_advise_load_complete "$comp_func" "$comp_name"
}

___x_cmd_advise_load_complete(){
    local comp_func="$1"; shift
    advise:debug --comp_func "$comp_func" --comp_name "$*" "load complete"
    if [ -n "$ZSH_VERSION" ]; then                      compdef "$comp_func" "$@"
    elif [[ "$BASH_VERSION" =~ (^3.*|^4.[0-3]) ]]; then complete -o nospace -F "$comp_func" "$@"
    else                                                complete -o nospace -o nosort -F "$comp_func" "$@"
    fi
}

___x_cmd_advise_run_filepath_(){
    case "$1" in
        x-cmd)
            ___x_cmd_advise_man_which___xcmd_ "$2" || return
            ___x_cmd_advise___load_xcmd_advise_util_file "$2" || return
            ;;
        *)  ___x_cmd_advise_which_ "$2" || return
            ;;
    esac
}

___x_cmd_advise_get_result_from_awk(){
    arg:init advise
    arg:1:nonempty
    local IFS="$___X_CMD_UNSEENCHAR_002"
    local s="${COMP_WORDS[*]}"
    s="${s#*"$IFS"}"

    # Handle the case that the last word has "@" or ":" in bash.
    COMP_LINE="${COMP_WORDS[*]}"
    local cur_1="${COMP_WORDS[COMP_CWORD-1]}"
    case "$cur_1" in
        *@|*:)
            if [ "${COMP_LINE% }" != "${COMP_LINE}" ]; then
                s="${s%"$cur_1""$IFS""$cur"}"
                s="${s}${cur_1}$cur"
            fi
            ;;
    esac
    ___x_cmd_advise_get_result_from_awk_ "$1" "$s"
}

___x_cmd_advise_get_result_from_awk_(){
    local filepath="$1"; shift
    local IFS="$___X_CMD_UNSEENCHAR_002"
    local argstr="$*"
    < "$filepath" \
    ___X_CMD_ADVISE_DEV_MOD="$___X_CMD_ADVISE_DEV_MOD" \
    ARGSTR="$argstr" \
    ___x_cmd_cmds_awk \
        -v ___X_CMD_SHELL="$___X_CMD_SHELL" \
        -v ADVISE_WITHOUT_DESC="$___X_CMD_ADVISE_WITHOUT_DESC" \
        -v ADVISE_NO_COLOR="$NO_COLOR" \
        -v ___X_CMD_ROOT_ADV="$___X_CMD_ROOT_ADV" \
        -v ___X_CMD_ADVISE_MAN_XCMD_FOLDER="$___X_CMD_ADVISE_MAN_XCMD_FOLDER" \
        -v ___X_CMD_HELP_LANGUAGE="${___X_CMD_HELP_LANGUAGE:-$___X_CMD_WEBSRC_REGION}" \
        -f "$___X_CMD_ROOT_MOD/awk/lib/core.awk" \
        -f "$___X_CMD_ROOT_MOD/awk/lib/sh.awk" \
        -f "$___X_CMD_ROOT_MOD/awk/lib/j/json.awk" \
        -f "$___X_CMD_ROOT_MOD/awk/lib/j/jiter.awk" \
        -f "$___X_CMD_ROOT_MOD/awk/lib/j/jqparse.awk" \
        -f "$___X_CMD_ROOT_MOD/awk/lib/j/jop.awk" \
        -f "$___X_CMD_ROOT_MOD/awk/lib/j/jcp.awk" \
        -f "$___X_CMD_ROOT_MOD/advise/lib/awk/advise.obj.awk"   \
        -f "$___X_CMD_ROOT_MOD/advise/lib/awk/advise.util.awk"  \
        -f "$___X_CMD_ROOT_MOD/advise/lib/awk/advise.share.awk" \
        -f "$___X_CMD_ROOT_MOD/advise/lib/awk/advise/advise.complete.awk" \
        -f "$___X_CMD_ROOT_MOD/advise/lib/awk/advise/advise.parse_argument.awk" \
        -f "$___X_CMD_ROOT_MOD/advise/lib/awk/advise/advise.main.awk"
}

if [ -n "$BASH_VERSION" ]; then
___x_cmd_advise___ltrim_bash_completions(){
    local cur="$1"; shift
    local prefix_word; local i; while [ "$#" -ge 1 ]; do
        i=${#COMPREPLY[*]}
        ((i == 0)) && return 0
        if [[ $cur == *$1* && $COMP_WORDBREAKS == *$1* ]]; then
            prefix_word=${cur%"${cur##*"$1"}"}
            COMPREPLY=("${COMPREPLY[@]}")
            while ((i-- > 0)); do
                COMPREPLY[i]=${COMPREPLY[i]#"$prefix_word"}
            done
        fi
        shift
    done
}

# TODO: has bugs
___x_cmd_advise___ltrim_bash_comp_words(){
    local IFS=' '
    [ "$COMP_LINE" != "${COMP_WORDS[*]}" ] || return
    IFS="$___X_CMD_UNSEENCHAR_002"
    local nline="${COMP_WORDS[*]}"
    ((${#COMP_WORDS[*]} == 0)) && return 0
    local prefix_word; local suffix_word;
    while [ "$#" -ge 1 ]; do
        if [[ $COMP_WORDBREAKS == *$1* && $nline == *$1* ]]; then
            prefix_word="${nline%%"${___X_CMD_UNSEENCHAR_002}${1}"*}"
            suffix_word="${nline#*"${1}${___X_CMD_UNSEENCHAR_002}"}"
            [ "$suffix_word" != "$nline" ] || suffix_word=
            nline="${prefix_word}${1}${suffix_word}"
        fi
        shift
    done
    COMP_WORDS=( $nline )
    [ "$nline" == "${nline%"$___X_CMD_UNSEENCHAR_002"}" ] || COMP_WORDS+=("")
    COMP_CWORD=$(( ${#COMP_WORDS[@]} - 1 ))
}

# Changed the global COMP_WORDBREAKS
___x_cmd_advise___ltrim_bash_comp_wordbreaks(){
    local prefix_word; while [ "$#" -ge 1 ]; do
        if [[ $COMP_WORDBREAKS == *$1* ]]; then
            prefix_word="${COMP_WORDBREAKS%%"$1"*}"
            COMP_WORDBREAKS="${prefix_word}${COMP_WORDBREAKS#*"$1"}"
        fi
        shift
    done
}

___x_cmd_advise___ltrim_bash_comp_wordbreaks "@" ":" "="

fi

___x_cmd_advise_ls(){
    local X_help_cmd; X_help_cmd='___x_cmd help -m advise ls' help:arg:parse
    [ ! -d "$___X_CMD_ADVISE_TMPDIR" ] || ___x_cmd fsiter "$___X_CMD_ADVISE_TMPDIR"
}

___x_cmd_advise_rm(){
    case "$1" in
        -h|--help)      M="advise rm" help:ret:0 ;;
        "")             ___x_cmd rmrf "$___X_CMD_ADVISE_TMPDIR" ;;
        *)              local x_=; ___x_cmd_advise_which_ "$1" || return
                        ___x_cmd rmrf "$x_"
    esac
}

___x_cmd_advise_which_(){
    [ -d "$___X_CMD_ADVISE_TMPDIR" ] || return
    x_="$___X_CMD_ADVISE_TMPDIR/$1"
    [ -f "$x_" ]
}

___x_cmd_advise_which(){
    case "$1" in
        -h|--help)      M="advise which" help:ret:0 ;;
        "")             printf "%s\n" "$___X_CMD_ADVISE_TMPDIR" ;;
        *)              local x_=; ___x_cmd_advise_which_ "$1" || return
                        printf "%s\n" "$x_"
    esac
}

___x_cmd_advise_cat(){
    local X_help_cmd; X_help_cmd='___x_cmd help -m advise cat' help:arg-null:parse
    local x_=; ___x_cmd_advise_which_ "$1" || return
    < "$x_" ___x_cmd jo
}
