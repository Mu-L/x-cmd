# shellcheck shell=dash

# TODO: support multiple file put
# TODO: support put dir
___x_cmd_hub_file_put(){
    local X_help_cmd='___x_cmd_hub___help file put'
    help:arg-null:parse

    local public; local force
    while [ $# -gt 0 ] ; do
        case "$1" in
            --public|-p)     public=true; shift ;;
            --force|-f)      force=true; shift ;;
            *) break ;;
        esac
    done

    local localfp="${1:?Provide local file}"
    [ -f "$localfp" ] || {  ___x_cmd_ui_tf false "$localfp not a file or diractory " >&2 ; return 1; }
    local remotefp; remotefp="$(____x_cmd_hub_file___remotefp "$localfp" "${2}")"
    hub:debug "localfp=$localfp, remotefp=$remotefp"

    local enc_localfp;
    enc_localfp="$(___x_cmd_hub___util_respath_to_localpath encdata "$remotefp")" || return 1

    printf "%s\n\n" "compress: xz" > "$enc_localfp"
    < "$localfp" ___x_cmd_hub_file___xz >> "$enc_localfp"

    # TODO: use pipline to put file
    if res="$(___x_cmd_hub___util_curl put /api/v0/file -F "file=@$enc_localfp" "res=$remotefp" "force=${force}")" ; then
        ___x_cmd_hub___util_handle_resp true "$res" "Upload $localfp to $remotefp:"
    else
        ___x_cmd_hub___util_handle_resp false "$res" "Failed to put $localfp to $remotefp:"
        return 1
    fi

    [ -z "$public" ] || ___x_cmd_hub_access___set --public "$remotefp"
}

___x_cmd_hub_file_eput(){
    local X_help_cmd='___x_cmd_hub___help file eput'
    help:arg-null:parse

    local force
    while [ $# -gt 0 ] ; do
        case "$1" in
            --force|-f)      force=true; shift ;;
            *) break ;;
        esac
    done

    local localfp="${1:?Provide local file}"
    [ -f "$localfp" ] || {  ___x_cmd_ui_tf false "$localfp not a file or diractory " >&2 ; return 1; }
    local remotefp; remotefp="$(____x_cmd_hub_file___remotefp "$localfp" "${2}")"
    hub:debug "localfp=$localfp, remotefp=$remotefp"

    local localfp_enc
    local filekey_path

    localfp_enc="$(___x_cmd_hub___util_respath_to_localpath encdata "$remotefp")" || return 1
    filekey_path="$(___x_cmd_hub___util_respath_to_localpath datakey "$remotefp")" || return 1

    # TODO: use pipline to put file
    printf "%s\n%s\n\n" "compress: xz" "keyname: $___X_CMD_HUB_KEYPAIR" > "$localfp_enc"
    < "$localfp" ___x_cmd_hub_file___xz | ___x_cmd_hub_file___encrypt_file "$filekey_path" >> "$localfp_enc" || {
        ___x_cmd_ui_tf false "Failed to encrypt $localfp to $localfp_enc" >&2
        return 1
    }

    local filekey_enc_path="${filekey_path}.enc"
    local x_ ; ___x_cmd_hub_keypair___ensure_key_ "$___X_CMD_HUB_KEYPAIR" public || return 1
    < "$filekey_path" ___x_cmd_hub_file___encrypt_filekey "$x_" > "$filekey_enc_path" || {
        ___x_cmd_ui_tf false "Failed to encrypt filekey to $filekey_enc_path" >&2
        return 1
    }

    hub:debug "Upload file_enc=$localfp_enc filekey_enc=$filekey_enc_path to $remotefp"
    if res="$(___x_cmd_hub___util_curl put /api/v0/file/enc \
        -F "file=@$localfp_enc" \
        -H "Encryption-filekey-base64: $(cat "$filekey_enc_path")" \
        "res=$remotefp" "force=${force}")" ; then
        ___x_cmd_hub___util_handle_resp true "$res" "Upload $localfp to $remotefp:"
    else
        ___x_cmd_hub___util_handle_resp false "$res" "Failed to put $localfp to $remotefp:"
        return 1
    fi
}

# ""  "" -> "$filename"
# "a" -> "a"
# "a/" -> "a/filename"
____x_cmd_hub_file___remotefp(){
    local localfp="${1:?Provide local file}"
    local respath="${2}"

    local filename="${localfp##*/}"
    [ -n "$respath" ] || respath="$filename"
    local remotefp="$respath"; [ "${respath%/}" = "$respath" ] || remotefp="${respath}${filename}"
    ___x_cmd_hub_file_normalize_respath "$remotefp"
}