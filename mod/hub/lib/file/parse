# shellcheck shell=dash

___x_cmd_hub_file_parse(){
    local src="$1"
    local dst="$2"

    <"$src" ___x_cmd_hub_file_parse_stream >"$dst"
}

___x_cmd_hub_file_parse_stream(){

    local srctype=
    local compress=
    local keyname=

    while read -r line; do
        case "$line" in
            srctype:\ *)    srctype="${line#*": "}" ;;
            compress:\ *)   compress="${line#*": "}"    ;;
            keyname:\ *)    keyname="${line#*": "}" ;;      # None means no such key ...
            "")             break ;;
        esac
    done

    if [ "$srctype" = link ]; then
        local url; url="$(cat)"
        curl -sSfL "$url"
        return
    fi

    hub:debug "srctype=$srctype, compress=$compress, keyname=$keyname"
    case "$compress" in
        # 7z)
        #     {
        #         case "$keyname" in
        #             "")     ;; # Just decompress
        #             "")     ;; # Use the key to decompress the 7z
        #         esac
        #     }

        #     ;;
        # xz)
        #     ___x_cmd_hub_file___decrypt_file "$filekey_path" | x xz unzip -  # unzip to dst file
        #     ;;
        #     # First you should compress, then you should deciph
        none) cat ;;
        aes-256-cbc)
            # TODO: use no http module
            local filekey_base64; filekey_base64="$(___x_cmd_http resp header encryption-filekey-base64)"
            local filekey_path; filekey_path="$(___x_cmd_hub___util_respath_to_localpath datakey "$respath")"  || return 1
            printf "%s" "$filekey_base64" | base64 -d | ___x_cmd_hub_file___decrypt_filekey "$___X_CMD_HUB_KEYPAIR"  > "$filekey_path" || {
                ___x_cmd_ui_tf false "Failed to decrypt filekey to $filekey_path" >&2
                return 1
            }

            ___x_cmd_hub_file___decrypt_file "$filekey_path"
            ;;
        *)  cat ;;
    esac
}
