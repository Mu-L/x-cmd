# shellcheck shell=dash

# TODO: support multiple file upload
# TODO: support upload dir
___x_cmd_hub_file_upload(){
    local X_help_cmd='___x_cmd_hub___help file upload'
    help:arg-null:parse

    local public; local no_encrypt; local force
    while [ $# -gt 0 ] ; do
        case "$1" in
            --public|-p)     public=true; shift ;;
            --no-encrypt)    no_encrypt=true; shift ;;
            --force|-f)      force=true; shift ;;
            *) break ;;
        esac
    done

    local localfp="${1:?Provide local file}"
    [ -f "$localfp" ] || {  ___x_cmd_ui_tf false "$localfp not a file or diractory " >&2 ; return 1; }
    local remotefp; remotefp="$(____x_cmd_hub_file___remotefp "$localfp" "${2}")"
    hub:debug "localfp=$localfp, remotefp=$remotefp"

    if [ -n "$no_encrypt" ] || [ -n "$public" ]; then
        ___x_cmd_hub_file_upload___no_encrypt_file "$localfp" "$remotefp" || return 1
    else
        ___x_cmd_hub_file_upload___encrypt_file "$localfp" "$remotefp" || return 1
    fi
    [ -z "$public" ] || ___x_cmd_hub_access___set --public "$remotefp"
}

___x_cmd_hub_file_upload___no_encrypt_file(){
    local localfp="${1:?Provide local file}"
    local remotefp="${2:?Provide remote file}"
    hub:debug "Upload file=$localfp to $remotefp"

    local enc_localfp;
    enc_localfp="$(___x_cmd_hub___util_respath_to_localpath encdata "$remotefp")" || return 1
    printf "%s\n\n" "compress: none" > "$enc_localfp"
    cat "$localfp" >> "$enc_localfp"

    # TODO: use pipline to upload file
    if res="$(___x_cmd_hub___util_send_file "$enc_localfp" "$remotefp" "force=${force}")" ; then
        ___x_cmd_hub___util_handle_resp true "$res" "Upload $localfp to $remotefp:"
    else
        ___x_cmd_hub___util_handle_resp false "$res" "Failed to upload $localfp to $remotefp:"
        return 1
    fi
}

___x_cmd_hub_file_upload___encrypt_file(){
    local localfp="${1:?Provide local file}"
    local remotefp="${2:?Provide remote file}"
    local localfp_enc;  localfp_enc="$(___x_cmd_hub___util_respath_to_localpath encdata "$remotefp")" || return 1
    local filekey_path; filekey_path="$(___x_cmd_hub___util_respath_to_localpath datakey "$remotefp")" || return 1

    # TODO: use pipline to upload file
    printf "%s\n%s\n\n" "compress: aes-256-cbc" "keyname: $___X_CMD_HUB_KEYPAIR" > "$localfp_enc"
    < "$localfp" ___x_cmd_hub_file___encrypt_file "$filekey_path" >> "$localfp_enc" || {
        ___x_cmd_ui_tf false "Failed to encrypt $localfp to $localfp_enc" >&2
        return 1
    }

    local filekey_enc_path="${filekey_path}.enc"
    local x_ ; ___x_cmd_hub_keypair___ensure_key_ "$___X_CMD_HUB_KEYPAIR" public || return 1
    < "$filekey_path" ___x_cmd_hub_file___encrypt_filekey "$x_" > "$filekey_enc_path" || {
        ___x_cmd_ui_tf false "Failed to encrypt filekey to $filekey_enc_path" >&2
        return 1
    }

    hub:debug "Upload file_enc=$localfp_enc filekey_enc=$filekey_enc_path to $remotefp"
    if res="$(___x_cmd_hub___util_send_enc_file "$localfp_enc" "$remotefp" "$filekey_enc_path" "force=${force}")" ; then
        ___x_cmd_hub___util_handle_resp true "$res" "Upload $localfp to $remotefp:"
    else
        ___x_cmd_hub___util_handle_resp false "$res" "Failed to upload $localfp to $remotefp:"
        return 1
    fi
}

# "" -> "$filename"
# "a" -> "a"
# "a/" -> "a/filename"
____x_cmd_hub_file___remotefp(){
    local localfp="${1:?Provide local file}"
    local respath="${2}"

    local filename ; filename="${localfp##*/}"
    [ -n "$respath" ] || respath="$filename"
    local remotefp="$respath"; [ "${respath%/}" = "$respath" ] || remotefp="${respath}${filename}"
    ___x_cmd_hub_file_normalize_respath "$remotefp"
}