# shellcheck shell=dash

___x_cmd_hub_key_rm(){
    while [ $# -gt 0 ]; do
        case "$1" in
            --help|-h|"")        ___x_cmd_hub___help key rm ; return 1 ;;
            --remote)            shift; ___x_cmd_hub_key_rm_remote "$@" ; return ;;
            -f|--force)          shift; force=true ;;
            *)  break ;;
        esac
    done

    local name="$1"
    if [ -z "$name" ]; then
        ___x_cmd_ui_tf false "Key name required. Like 'x hub key rm <name>'"
        return 1
    fi

    if [ -z "$force" ] && ! x ui yesno "Are you sure to remove the key '$name'?" ; then
        return 1
    fi

    local key_path; key_path="$___X_CMD_HUB_KEY_PATH/$(___x_cmd_hub_cur get userid)"
    if [ ! -d "$key_path" ]; then
        hub:warn "No key found. Use 'x hub key gen' or 'x hub key load' to generate or load a key"
        return 1
    fi

    x rmrf "$key_path/${name}_private.pem" "$key_path/${name}_public.pem" || return 1
}

___x_cmd_hub_key_rm_remote(){
    local name="$1"
    if [ -z "$name" ]; then
        ___x_cmd_ui_tf false "Key name required. Like 'x hub key rm <name>'"
        return 1
    fi

    if [ -z "$force" ] && ! x ui yesno 'Are you sure to delete key '"'$name'"'? you should backup it first.' ; then
        ___x_cmd_ui_tf false "Cancelled"
        return 1
    fi

    local res; if ! res="$(___x_cmd_hub___util_curl delete "/api/v0/key/$name" type=private)" ; then
        ___x_cmd_hub___util_handle_resp false "$res" "Failed to delete key '$name'"
        return 1
    fi

    if ! res="$(___x_cmd_hub___util_curl delete "/api/v0/key/$name" type=public)" ; then
        ___x_cmd_hub___util_handle_resp false "$res" "Failed to delete key '$name'"
        return 1
    fi

    ___x_cmd_hub___util_handle_resp true "$res" "Key '$name' deleted"
}