# shellcheck shell=sh disable=SC3043

___x_cmd_hub___util_user_id(){
    local res
    if ! res="$(NO_AUTH=1 ___x_cmd_hub___util_curl get "/api/v0/account/id" "username=$1")" ; then
        ___x_cmd_hub___util_handle_resp false "$res" "Failed to get user id for $1"
        return 1
    fi

    printf "%s" "$res" | (  x jo env . id=.id ; printf "%s\n" "$id")
}

___x_cmd_hub___util_handle_resp(){
    local isSuccess="$1"; local resp="$2"; local msg="$3"; shift 3
    local resp_msg; resp_msg="$(printf "%s" "$resp" | {
        x jo env . resp_msg=.msg ; printf "%s\n" "$resp_msg" ;
    })"

    [ -z "$resp_msg" ] || {
        ___x_cmd_ui_tf "$isSuccess" "$msg" "resp: $resp_msg" >&2
        return
    }

    if [ -n "$resp" ] ; then  ___x_cmd_ui_tf "$isSuccess" "$msg" "resp: $resp" "$@" >&2
    else                      ___x_cmd_ui_tf "$isSuccess" "$msg"               "$@" >&2  ;fi
}

___x_cmd_hub___util_subcmd_invalid(){
    local subcmd="${1}"
    local arg="${2}"
    if [ -z "$arg" ]; then ___x_cmd_ui_tf false "Subcommand required. See 'x hub $subcmd --help|-h':" >&2
    else                     ___x_cmd_ui_tf false "'$arg' is not a subcommand. See 'x hub $subcmd --help|-h':" >&2 ; fi
    return 1
}

___x_cmd_hub___help(){
    x help -m hub "$@" >&2
    return 1
}

___x_cmd_hub___util_st_tab(){
    if ! ___x_cmd_is_interative_tty || [ ! -t 1 ]; then
        x csv static_tab
    else
        x csv static_tab "$@"
    fi
}

___x_cmd_hub___util_read_password_(){
    local password
    printf "%s" "$1"
    stty -echo
    read -r password
    stty echo
    printf "\n"
    x_="$password"
}

# Section: encrypt

# from aaa.sh to aaa.sh.enc
___x_cmd_hub___util_encrypt(){
    local pass
    while [ "$#" -gt 0 ]; do
        case "$1" in
            --pass|-p) pass="$2"; shift 2 ;;
            *) break ;;
        esac
    done

    x openssl env -aes-256-cbc -salt -pbkdf2 -in "$1" -out "${1}.enc" -pass pass:"$pass"
}

# from aaa.sh.enc to aaa.sh
___x_cmd_hub___util_decrypt(){
    local pass
    while [ "$#" -gt 0 ]; do
        case "$1" in
            --pass|-p) pass="$2"; shift 2 ;;
            *) break ;;
        esac
    done

    x openssl enc -d -aes-256-cbc -pbkdf2 -in "$1" -out "${1%.*}"  -pass pass:"$pass"
}

# EndSection

# Section: curl

___X_CMD_HUB_SERVICE_URL="https://hub.x-cmd.com"
___x_cmd_hub___util_curl() (
    local method="${1:?Provide method}"
    local url_path="${2:?Provide url_path}"; shift 2

    [ -n "$NO_AUTH" ] || {
        local token; ___x_cmd_hub_cur token:=
        [ -n "$token" ] || return 1
        ___x_cmd_http header put Authorization "$token"
    }

    hub:debug "Command " "$url_path" "$@"
    case "$method" in
        get)              ___x_cmd_http get "$___X_CMD_HUB_SERVICE_URL$url_path" "$@"              ;;
        post|patch|put)   ___x_cmd_http "$method" json "$___X_CMD_HUB_SERVICE_URL$url_path" "$@"   ;;
        delete)
            ___x_cmd_http qs mput "$@"
            ___x_cmd_http delete "$___X_CMD_HUB_SERVICE_URL$url_path"
        ;;
        *)      hub:error "Unknown method: $method" ;;
    # TODO: Maybe has other way to close the http module log
    esac 2>/dev/null || {
        printf "%s\n" "$(___x_cmd_http resp body)"
        return 1
    }
)

# ___x_cmd_hub___util_curl_v2 get "/api/v0/key/default" type=public
___x_cmd_hub___util_curl_v2()(
    local method="${1:?Provide method}"
    local url_path="${2:?Provide url_path}"; shift 2
    local resp_path="$___X_CMD_HUB_TMP/resp.$$.out"
    x rmrf "$resp_path"

    local header=""
    [ -n "$NO_AUTH" ] || {
        local token; ___x_cmd_hub_cur token:=
        [ -n "$token" ] || return 1
        header='-H "Authorization: '"$token"'"'
    }

    hub:debug "Command " "$url_path" "$@"
    local cmd
    case "$method" in
        get)
            local x_; ___x_cmd_hub___util_curl_handle_query_ "$@"
            local query; query="$x_"
            cmd="x curl -sS -X GET -o '$resp_path' -w '%{http_code}' \
                $header \
                '$___X_CMD_HUB_SERVICE_URL$url_path$query'" ;;
        put)
            local x_; ___x_cmd_hub___util_curl_handle_body_ "$@"
            local body; body="$x_"
            cmd="x curl -sS -X PUT -o '$resp_path' -w '%{http_code}' \
                $header \
                -H 'Content-Type: application/json' \
                -d '$body' \
                '$___X_CMD_HUB_SERVICE_URL$url_path'" ;;
        *)      hub:error "Unknown method: $method" ;;
    esac

    hub:debug "Exec cmd: $cmd"
    local http_code; http_code="$(eval "$cmd")" || return 1
    command cat "$resp_path"

    case "$http_code" in
        2*)  return 0 ;;
        404) return 4 ;;
        *)   return 1 ;;
    esac
)

# "$@" is type=public aa=nnn dd=eee
___x_cmd_hub___util_curl_handle_query_(){
    x_=""
    for arg in "$@"; do
        x_="${x_}&$arg"
    done
    [ -z "$x_" ] || x_="?${x_#&}"
}

# "$@" is type=public aa=nnn dd=eee
___x_cmd_hub___util_curl_handle_body_(){
    x_=""
    for arg in "$@"; do
        x_="${x_},\"${arg%%=*}\":\"${arg#*=}\""
    done
    [ -z "$x_" ] || x_="{${x_#?}}"
}

___x_cmd_hub___util_send_reskey() {
    local key_path="${1:?key_path is required}"
    local type="${2:?type is required}"
    local name="${3:?name is required}"

    local token; token="$(___x_cmd_hub___util_get_token)" || return 1
    local cmd; cmd="x curl -sS \
        -X POST -o '$___X_CMD_HUB_TMP/resp.$$.out' -w '%{http_code}' \
        -F 'file=@$key_path' \
        '$___X_CMD_HUB_SERVICE_URL/api/v0/key?token=${token}&type=${type}&name=${name}'"

    hub:debug "Exec cmd: $cmd"
    local http_code; http_code="$(eval "$cmd")" || return 1
    command cat "$___X_CMD_HUB_TMP/resp.$$.out"

    case "$http_code" in
        2*) return 0 ;;
        *)  hub:error "Failed to upload file=${key_path}, http_code=$http_code" ; return 1 ;;
    esac
}

___x_cmd_hub___util_send_file() {
    local localfp="${1:?Provide local file}"
    local respath="${2:?Provide respath}"

    local token; token="$(___x_cmd_hub___util_get_token)" || return 1
    local cmd; cmd="curl -sS -X PUT \
        -X PUT -o '$___X_CMD_HUB_TMP/resp.$$.out' -w '%{http_code}' \
        -F 'file=@$localfp' \
        '$___X_CMD_HUB_SERVICE_URL/api/v0/file?token=${token}&res=${respath}'"
    # TODO: when http return error code, curl will not return error code

    hub:debug "Exec cmd: $cmd"
    local http_code; http_code="$(eval "$cmd")" || return 1
    command cat "$___X_CMD_HUB_TMP/resp.$$.out"

    case "$http_code" in
        2*) return 0 ;;
        *)  hub:error "Failed to upload file=${key_path}, http_code=$http_code" ; return 1 ;;
    esac
}

#EndSection

# Section: math ___x_cmd_hub___util_unit_suffixes, ___x_cmd_hub___util_percent

# use unit suffixes. Byte, Kilobyte, Megabyte, Gigabyte, Terabyte and Petabyte in order to reduce the number of digits to four or fewer using base 2 for sizes
___x_cmd_hub___util_unit_suffixes(){
    local base="${1:?Provide base}"
    local unit="B"
    base=$((base*100))
    if [ "$base" -ge 102400 ] ; then
        base=$((base/1024))
        unit="KB"
    fi

    if [ "$base" -ge 102400 ] ; then
        base=$((base/1024))
        unit="MB"
    fi

    if [ "$base" -ge 102400 ] ; then
        base=$((base/1024))
        unit="GB"
    fi

    if [ "$base" -ge 102400 ] ; then
        base=$((base/1024))
        unit="TB"
    fi

    if [ "$base" -ge 102400 ] ; then
        base=$((base/1024))
        unit="PB"
    fi

    printf "%s %s" "$((base/100)).$((base%100))" "$unit"
}

___x_cmd_hub___util_percent(){
    local base="${1:?Provide base}"
    local total="${2:?Provide total}"
    base="$((base*100*100/total))"
    printf "%s" "$((base/100)).$((base%100)) %"
}

#EndSection

# Section: token_generate

___x_cmd_hub___util_get_token(){
    local token; token=$(___x_cmd_hub_cfg --get token)
    if [ ! "$token" ]; then
        ___x_cmd_ui_tf false "Token is empty, please 'x hub login' first:" >&2
        return 1
    fi
    printf "%s\n" "$token"
}

___x_cmd_hub___util_save_token_with_ui(){
    local token="${1}"
    if ___x_cmd_hub_get_userinfo_by_token "${token}" ; then
        if [ -n "$(___x_cmd_hub_cfg --get token)" ]; then
            hub:info "You have already login, will logout first"
            ___x_cmd_hub_account_logout
        fi
        ___x_cmd_hub_cfg token="${token}"
        ___x_cmd_hub___util_handle_resp true "" "Save token to config file"
        local x_; ___x_cmd_hub_key___ensure_key_ default private || return 1
        hub:info "Login success"
    else
        ___x_cmd_ui_tf false "Failed" >&2
        return 1
    fi
}

___x_cmd_hub___util_token_generate(){
    printf "%s%s" "$(date +%s)" "$(x rand uuid)" | x md5
}

# EndSection
