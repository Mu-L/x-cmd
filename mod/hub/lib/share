# shellcheck shell=dash

___x_cmd_hub_share(){
    local op="$1"
    case "$op" in
        -h|--help)    shift ; ___x_cmd_hub___help share ; return 1 ;;
        set|unset|ls) shift ; "___x_cmd_hub_share_$op" "$@"           ;;
        "")        ___x_cmd_hub___help share ; return 1 ;;
        *)         ___x_cmd_hub___util_subcmd_invalid "share" "$@" ;;
    esac
}

# ___x_cmd_hub_share_ls(){
#     local json
#     case "$1" in
#         --json|-j)    json=true; shift ;;
#         --help|-h)    ___x_cmd_hub___help share ls ; return 1 ;;
#     esac

#     local res
#     if ! res="$(___x_cmd_hub___util_curl_v2 get /api/v0/share)" ; then
#         ___x_cmd_hub___util_handle_resp false "$res" "Failed to list shares : "
#         return 1
#     fi

#     printf "%s" "$res" | \
#         x jo 2c                .path  .isPublic .userList  .createdAt | \
#         x csv header --add     PATH   IS_PUBLIC USER_LIST  CREATE_AT  | \
#         ___x_cmd_hub___util_st_tab  -      10    100%
# }

___x_cmd_hub_share_set(){
    ___x_cmd_hub_share___set "$@"
}

___x_cmd_hub_share___set(){
    local public
    local user
    while [ $# -gt 0 ]; do
        case "$1" in
            --public)       public=true; shift ;;
            --user)         user="$2"; shift 2 ;;
            --help|-h)      ___x_cmd_hub___help share set >&2 ; return 1 ;;
            *) break ;;
        esac
    done

    if [ -z "$user" ] && [ -z "$public" ] ; then
        ___x_cmd_hub___util_handle_resp false "" "Please provide --user <username> or --public"
        return 1
    fi

    local respath="${1:?Provide respath}"
    respath="$(___x_cmd_hub_file_normalize_respath "$respath")"

    if [ -n "$user" ] ; then
        ___x_cmd_hub_share___handle_filekey "$user" "$respath" || return
    fi

    local res; res="$(___x_cmd_hub___util_curl_v2 put /api/v0/share "res=$respath" "isPublic=${public:-false}" username="$user")" || {
        ___x_cmd_hub___util_handle_resp false "$res" "Failed to set share:"
        return 1
    }

    [ -z "$json" ] || { printf "%s\n" "$res" ; return 0 ; }
    ___x_cmd_hub___util_handle_resp true "" "Success to set share for $respath"
}

___x_cmd_hub_share___handle_filekey(){
    local user="${1:?Provide user}"
    local respath="${2:?Provide respath}"

    # step1: download user public key
    hub:debug "Step1 => Downloading public key for $user"
    if ! res="$(___x_cmd_hub___util_curl_v2 get /api/v0/key/default type=public "username=$user")" ; then
        ___x_cmd_hub___util_handle_resp false "$res" "Failed to get public key for $user"
        return
    fi
    local pubkey_path
    pubkey_path="$___X_CMD_HUB_DATA/$(___x_cmd_hub___util_user_id "$user")/keypair/default_public.pem" || return 1
    printf "%s" "$res" > "$pubkey_path"
    hub:info "Downloaded public key for $user to $pubkey_path"

    # step2: ensure your key is loaded
    hub:debug "Step2 => Ensure your key is loaded"
    local filekey_path; filekey_path="$(___x_cmd_hub___util_user_dir datakey)/${respath#*/}/filekey" || return 1
    x mkdirp "${filekey_path%/*}"
    local x_ ; local private_key_path
    ___x_cmd_hub_keypair___ensure_key_ default private || return 1
    private_key_path="$x_"

    # step3: download filekey
    hub:debug "Step3 => Downloading filekey"
    if ! res="$(___x_cmd_hub___util_curl_v2 get /api/v0/filekey "res=$respath")" ; then
        ___x_cmd_hub___util_handle_resp false "$res" "Failed to get filekey for $respath"
        return 1
    fi
    local filekey_base64="$res"

    # step4: decrypt filekey
    hub:debug "Step4 => Decrypt filekey"
    printf "%s" "$filekey_base64" | base64 -d > "$filekey_path.enc"
    ___x_cmd_hub_file___decrypt_filekey "$filekey_path.enc" "$filekey_path" "$private_key_path" || {
        ___x_cmd_ui_tf false "Failed to decrypt filekey to $filekey_path" >&2
        return 1
    }

    # step5: encrypt filekey use user's public key
    hub:debug "Step5 => Encrypt filekey use user's public key"

    local sharekey_enc_path
    sharekey_enc_path="$(___x_cmd_hub___util_user_dir sharekey)/$(___x_cmd_hub___util_user_id "$user")/${respath#*/}/filekey.share.enc" || return 1
    x mkdirp "${sharekey_enc_path%/*}"
    ___x_cmd_hub_file___encrypt_filekey "$filekey_path" "$sharekey_enc_path" "$pubkey_path" || {
        ___x_cmd_ui_tf false "Failed to encrypt filekey to $sharekey_enc_path" >&2
        return 1
    }

    # step6: upload filekey
    hub:debug "Step6 => Uploading filekey"
    if ! res="$(___x_cmd_hub___util_curl_v2 put /api/v0/filekey "res=$respath" "filekey=$(< "$sharekey_enc_path" base64)" "username=$user")" ; then
        ___x_cmd_hub___util_handle_resp false "$res" "Failed to upload filekey for $respath"
        return 1
    fi
}

___x_cmd_hub_share_unset(){
    case "$1" in
        --help|-h)    ___x_cmd_hub___help share rm >&2 ; return 1 ;;
    esac

    local respath="${1:?Provide respath}"
    respath="$(___x_cmd_hub_file_normalize_respath "$respath")"

    local res
    if ! res="$(___x_cmd_hub___util_curl delete /api/v0/share "res=$respath")" ; then
        ___x_cmd_hub___util_handle_resp false "$res" "Failed to remove share: "
        return 1
    fi

    ___x_cmd_hub___util_handle_resp true "$res" "Success to rm share for $respath"
}
