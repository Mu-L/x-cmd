# shellcheck shell=dash

xrc:mod:lib cd  util back pick relm/_index search history/_index

! ___x_cmd_is_suitable_advise_env || xrc:mod:lib cd  advise

# jump to a folder contains: jc bin
# jump to a child folder: jc lib
# jump to a father folder: jo opening; c .

# c backward
# c forward = find
# c - = history in environment
# c <filename> = unmatch to search history or rules

# c /u/l/

# TODO:
# c ... code
# c :xb code        # go to the folder and open code in the folder

# TODO:
# c :gh/        ==> gh ==> https://github.com/
# c :ggh/       ==> git@github.com

___x_cmd_cd___main(){
    if [ "$#" -eq 0 ]; then
        ___x_cmd_cd_search___history
        return
    fi

    local p="$1";           shift
    if [ -d "$p" ]; then
        ___x_cmd_cd_origin "$p" "$@";
        return
    fi

    case "$p" in
        -h|--help)          M='cd' help:ret:0 ;;
        -r|--relm)          ___x_cmd_cd_relm                    "$@" ;;
        -b)                 ___x_cmd_cd_back                    "$@" ;;

        '~')                ___x_cmd_cd_origin "$HOME"               ;;
        '~'/*)              ___x_cmd_cd_origin "$HOME"/"${p#*/}"     ;;

        # -i)                 ___x_cmd_cd_pick_set                "$@" ;;

        # cd-forward        # Might cause some problem
        -f)                 ___x_cmd_cd_forward                 "$@" ;;
        --history)          ___x_cmd_cd_history                 "$@" ;;

        -)                  ___x_cmd_cd_origin "$OLDPWD"        "$@" ;;
        ""|~*|-L|-P|-q|-s|-*|+*)
                            ___x_cmd_cd_origin "$p"             "$@" ;;

        :|:*)               ___x_cmd_cd_relm___magic "${p}"     "$@" ;;
        *://*)              ___x_cmd_cd_origin "$p"             "$@" ;;

        # cd-back
        ...)                ___x_cmd_cd_back___nv               "$@" ;;
        .../*)              ___x_cmd_cd_back    "${p#*/}"       "$@" ;;

        # ../*)               ___x_cmd_cd_back    "${p#*/}"       "$@" ;;
        # ./*)                ___x_cmd_cd_forward "${p#./}"       "$@" ;;

        # history
        ,*)                 ___x_cmd_cd_search___history_match "${p#,}" "$@" ;;

        # cd with find
        # %*)                 ___x_cmd_cd_search___xcmdroot   "${p#*%}"   "$@" ;;      # consider
        # ,*)                 ___x_cmd_cd_search___home       "${p#*,}"   "$@" ;;      # = is not support in zsh, that's why we use ,

        *)                  [ -z "$___X_CMD_CD_COMPATIBLE" ] ||  N=cd M="Invalid path -> $p" log:ret:1
                            case "$p" in
                                /*)     ___x_cmd_cd_goto___pickfromiter / "${p#/}"    "$@" ;;
                                */*)    ___x_cmd_cd_goto___pickfromiter . "${p}"      "$@" ;;
                                *)      ___x_cmd_cd_goto___pickfromiter . "${p}"      "$@" ;;
                            esac
    esac
}

___x_cmd_cd_init(){
    ___x_cmd_cd_relm___init
}

___x_cmd_cd_init

___x_cmd_cd_forward(){
    [ "$#" -gt 0 ] || N=cd M="Please provide the keyword forward" log:ret:64
    ___x_cmd_cd_search___path "$@"
}

## Section: cd origin

# c gh://x-bash/advise

___x_cmd_cd_origin(){
    [ "$#" -gt 0 ]  ||      set - "$HOME"

    local ppp="$1";         local domain
    case "$ppp" in
        gh:*)               domain=github.com   ;;
        gt:*)               domain=gitee.com    ;;
        gl:*)               domain=gitlab.com   ;;
        gcode:*)            domain=gitcode.net  ;;
        *)                  ___x_cmd_cd_origin___chdir "$@"; return ;;
    esac

    ppp="${ppp#*:}"
    shift
    ___x_cmd_cd_origin___git "${ppp#//}" "$@"
}

___X_CMD_CD_GIT_STORE="$___X_CMD_ROOT_DATA/git"

# domain=github.com
___x_cmd_cd_origin___git(){
    local dir="$1"; shift
    if [ ! -d "$___X_CMD_CD_GIT_STORE/$domain/$dir" ]; then
        # NOTICE: The reason using subshell is to make sure current dir unchanged when ctrl-c interrupt.
        (
            ___x_cmd mcd "$___X_CMD_CD_GIT_STORE/$domain/${dir%/*}"
            ___x_cmd_cmds git clone "git@${domain}:$dir"
        ) || return
    fi

    ___x_cmd_cd_origin___chdir "$___X_CMD_CD_GIT_STORE/$domain/$dir" "$@"
}

___x_cmd_cd_origin___chdir(){
    local dir="$1"; shift

    local ret=0
    if [ "$#" -gt 0 ]; then
        local ___X_CMD_CD_ORIGIN_PWD="$PWD"
        ___x_cmd_cd_origin___chdir0 "$dir"
        cd:debug -c "$*" "chdir to exec"
        "$@" || ret=$?
        ___x_cmd_cd_origin___chdir0 "$___X_CMD_CD_ORIGIN_PWD"
        return $ret
    fi

    cd:debug "chdir to $dir, [PWD=$PWD]"
    ___x_cmd_cmds_cd "$dir" 2>/dev/null || N=cd M="Invalid directory [path=$dir]" log:ret:1

    # if [ "${-#*i}${___X_CMD_FS_DEBUG}" != "$-" ] && [ -t 1 ] ; then
    if { ___x_cmd_is_interactive || [ -n "$___X_CMD_FS_DEBUG" ]; } && [ -t 1 ]; then
        ___x_cmd_cd_history___top "$PWD"
    fi
}

___x_cmd_cd_origin___chdir0(){
    local dir="$1"
    ___x_cmd_cd0 "$dir" 2>/dev/null || N=cd M="Invalid directory [path=$dir]" log:ret:1
}

