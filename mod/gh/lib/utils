# shellcheck shell=sh
# shellcheck disable=SC2039,3043
# shellcheck disable=SC2046

# Section: Help
_____x_cmd_gh_help__token_setting(){
    printf "\n%s %s \n%s\n" \
        "$(___x_cmd_ui yellow 'Run command to add|repleace token:')" \
        "$(___x_cmd_ui bold cyan "\`x gh token <token>\`")"   \
        "$(___x_cmd_ui 'https://github.com/settings/tokens')"
}

_____x_cmd_gh_help(){
    command -v ___x_cmd_advise_gen_help >/dev/null || xrc:mod advise/lib/gen_help
    ___x_cmd_advise_gen_help "$___X_CMD_ROOT_MOD/gh/res/advise.jso" "$@"
}

# EndSection

# Section: HTTP header & body & request
___x_cmd_gh_resp_header() {
    cat "$___X_CMD_GH_TMP/.____x_cmd_gh_curl_header"
}

___x_cmd_gh_resp_code(){
    ___x_cmd_gh_resp_header  | awk '$1 ~/HTTP\/2$/ {print ($2+0);exit(0)}'
}

___x_cmd_gh_curl(){
    local op="$1"
    local _api_url="$2"
    shift 2
    local ___X_CMD_API_GH_HEADER="-s -H \"Accept:application/vnd.github.v3+json\" -D \"$___X_CMD_GH_TMP/.____x_cmd_gh_curl_header\""

    local _curl_host_tmp=""
    local ___X_CMD_API_GH_TOKEN=""
    ___x_cmd_gh_config___var  ___X_CMD_API_GH_TOKEN=token _curl_host_tmp=host 2>/dev/null
    local ___X_CMD_API_GH_HOST="${___X_CMD_API_GH_HOST:-"$_curl_host_tmp"}"

    local ___X_CMD_GH_SHOW_HTTP_CODE=1
    case "$op" in
         get)
            if [ -n "$NO_CACHE" ]; then
                ___x_cmd_api_gh get "$_api_url" $(eval "printf '%s ' $(x curl gencode $(___x_cmd_gh_curl___use_query_data "$@"))")
            else
                x ccmd 10s --        eval "___X_CMD_API_GH_HOST=$___X_CMD_API_GH_HOST ___X_CMD_API_GH_TOKEN=$___X_CMD_API_GH_TOKEN ___x_cmd_api_gh get $_api_url $(eval "printf '%s ' $(x curl gencode $(___x_cmd_gh_curl___use_query_data "$@"))")"
            fi
            ___x_cmd_gh_http_error   eval "___X_CMD_API_GH_HOST=$___X_CMD_API_GH_HOST ___X_CMD_API_GH_TOKEN=$___X_CMD_API_GH_TOKEN ___x_cmd_api_gh get $_api_url $(eval "printf '%s ' $(x curl gencode $(___x_cmd_gh_curl___use_query_data "$@"))")"
            ;;
        post|put|patch|del)
            ___x_cmd_api_gh "$op" "$_api_url" "$(x curl gencode "$@")"
            ___x_cmd_gh_http_error
            ;;
        download)
            local __out="${1?:"Please provide output dir"}"
            x mkdirp "${__out%/*}"
            ___X_CMD_API_GH_HEADER="--progress-bar -H \"Accept:application/vnd.github.v3+json\" -D \"$___X_CMD_GH_TMP/.____x_cmd_gh_curl_header\""
            ___x_cmd_api_gh "${___X_CMD_GH_DOWNLOAD_REQ_METHOD:-"get"}" "$_api_url" -o "\"$__out\""
            if ! ___x_cmd_gh_http_error; then
                (
                    command cat "$__out" 2>/dev/null | x jo env . gh_resp_msg=.message gh_resp_err=.errors
                    ___x_cmd_ui_tf false "Download Failure" >&2
                    ___x_cmd_gh____handle_resp
                    return 1
                )
            fi
            ;;
        upload)
            local __file_type="\"Content-Type: ${file_type:-"octet-stream"}\""
            ___X_CMD_API_GH_HEADER="--progress-bar -H \"Accept:application/vnd.github.v3+json\" -D \"$___X_CMD_GH_TMP/.____x_cmd_gh_curl_header\" -H ${__file_type}"
            local __file_path="${1?:"Please provide upload filepath"}"; shift;
            [ -f "$__file_path" ] || {
                gh:error "Upload Failure: Not found target file. Please check file exist: $__file_path"
                return 1
            }
            gh:info "Uploading file..."
            ___x_cmd_api_gh "${___X_CMD_GH_UPLOAD_REQ_METHOD:-"post"}" "$_api_url" -T "\"$__file_path\""
            ___x_cmd_gh_http_error
            ;;
    esac
}

# shellcheck disable=SC2154
___x_cmd_gh_curl___use_query_data(){
    [ $# -gt 0 ] || return
    local name=""
    printf "%s " "-G"
    for name in "$@";
    do
        if [ "$name" = "p" ];then  [ -z "$p" ] || printf "%s " "path==$p";
        else                                      printf "%s " "$name==" ;
        fi
    done
}

___x_cmd_gh_http_error(){
    local http_resp_code=""
    http_resp_code=$(___x_cmd_gh_resp_code)
    if [ -n "$http_resp_code" ] && [ "$http_resp_code" -ge 200 ] && [ "$http_resp_code" -le 303 ]; then
        return 0
    else
        [ $# -eq 0 ] || {
            gh:debug "Cache Clear"
            x ccmd invalidate "$@" 1>/dev/null 2>&1
        }
        [ -z "$___X_CMD_GH_SHOW_HTTP_CODE" ] || {
            gh:error "HTTP Code is $http_resp_code"
            if command -v unset 1>/dev/null; then
                unset ___X_CMD_GH_SHOW_HTTP_CODE
            fi
        }
        return 1
    fi
}

___x_cmd_gh____printf_error(){
    if ! ___x_cmd_is_interative_tty || [ ! -t 2 ] || [ -n "$NO_COLOR" ]; then
        printf "  - ErrorMsg: %s\n" "$1" >&2
    else
        printf "  \033[31m-\033[0m \033[1mErrorMsg: \033[31m%s\033[0m\n" "$1" >&2
    fi
}
___x_cmd_gh____handle_resp(){
    [ -z "$gh_resp_msg" ] || ___x_cmd_gh____printf_error "$gh_resp_msg"
    [ -z "$gh_resp_err" ] || ___x_cmd_gh____printf_error "$gh_resp_err"
}
# EndSection

# Section: Resolve pagination
___gh_ui_mutual() {
    local tmp="$1"
    shift 1
    if [ -n "$json" ] || [ -n "$ENFORCE_JSON" ] ; then
        ENFORCE_JSON=1 "$@"
    else
        # run ui table
        eval "$tmp"
    fi
    local ___gh_exit_code="$?"
    [ "$___gh_exit_code" -eq 0 ] || {
        ___x_cmd_ui_tf false "${___gh_error_msg:-"Couldn't find any data"}:" >&2
        return "$___gh_exit_code"
    }
}

___x_cmd_gh_get_multi() {
    if [ -n "$page" ] || [ -n "$per_page" ]; then
        ___x_cmd_gh_curl get "$@" page per_page
        return
    fi

    local page=1
    local per_page=100
    if [ -n "$json" ] || [ -n "$ENFORCE_JSON" ]; then
        ___x_cmd_gh_get_multi___json_prt "$@"
    else
        ___x_cmd_gh_get_multi___ui_table "$@"
    fi

}
___x_cmd_gh_get_multi___ui_table(){
    ___x_cmd_gh_curl get "$@" page per_page
    printf "\n"
    local next_url=""
    _____x_cmd_gh_next_url
    [ -n "$next_url" ] || return

    while [ -n "$next_url" ]; do
        ___x_cmd_gh_curl get "$next_url"
        printf "\n"
        _____x_cmd_gh_next_url
    done
}

___x_cmd_gh_get_multi___json_prt(){
    local tmp=""
    tmp=$(mktemp)
    ___x_cmd_gh_curl get "$@" page per_page > "$tmp"
    printf "\n" >> "$tmp"

    local next_url=""
    _____x_cmd_gh_next_url
    if [ -z "$next_url" ]; then
        cat "$tmp"
        x rmrf "$tmp"
        return
    fi

    while [ -n "$next_url" ]; do
        ___x_cmd_gh_curl get "$next_url" >> "$tmp"
        printf "\n" >> "$tmp"
        _____x_cmd_gh_next_url
    done
    < "$tmp" x jo q0 \*.\* . | awk 'BEGIN{ print "["}
        END{ print "]"}
        {
            if ($0 == "") next
            if ((NR != 1) && ( aaa == 0 )) print ","
            if (($0 == "{") || ( $0 == "[")) aaa++
            if (($0 == "}") || ( $0 == "]")) aaa--
            print $0
        }'
    x rmrf "$tmp"
}

_____x_cmd_gh_next_url() {
    next_url="$(grep "link:" "$___X_CMD_GH_TMP/.____x_cmd_gh_curl_header")"
    next_url="${next_url#*'rel="prev", <'}"
    local tmp_url="${next_url%%'>; rel="next"'*}"
    if [ "$next_url" != "$tmp_url" ]; then
        next_url="${tmp_url#*'.com'*}"
    else
        next_url=""
    fi
}

# EndSection

# Section: Default param util
alias ___x_cmd_gh_param_init_owner_repo='
    local owner_repo=""
    ___x_cmd_gh_param_normalize_repo  || return
'

# shellcheck disable=SC2154,SC2034
___x_cmd_gh_param_normalize_repo() {
    local op="$repo"
    [ -z "$op" ] && op="$1"
    case "$op" in
    */*)
        owner_repo="$op"
        ;;
    "")
        if [ -n "$___X_CMD_GH_CURRENT_repo" ]; then
            if [ "${___X_CMD_GH_CURRENT_repo##*/}" != "${___X_CMD_GH_CURRENT_repo}" ];then
                owner_repo="$___X_CMD_GH_CURRENT_repo"
            elif [ -n "$___X_CMD_GH_CURRENT_owner" ]; then
                owner_repo="${___X_CMD_GH_CURRENT_owner}/${___X_CMD_GH_CURRENT_repo}"
            else
                if ! owner_repo="$(___x_cmd_gh_config_get owner)/${___X_CMD_GH_CURRENT_repo}"; then
                    gh:error "No owner provided. Default owner not set."
                    gh:warn -h "$(x str ml wrap "$(_____x_cmd_gh_help__token_setting)" '    ')" -m "Can retry setup token to update owner.${___X_CMD_UNSEENCHAR_NEWLINE}Or check your current token setting."
                    return 1
                fi
            fi
        else
            owner_repo="$(_____x_cmd_git_repo)"
        fi
        ;;
    *)
        if [ -z "$___X_CMD_GH_CURRENT_owner" ]; then
            local ___X_CMD_GH_CURRENT_owner
            if ! ___X_CMD_GH_CURRENT_owner="$(___x_cmd_gh_config_get owner)"; then
                gh:error "No owner provided. Default owner not set."
                gh:warn -h "$(x str ml wrap "$(_____x_cmd_gh_help__token_setting)" '    ')" -m "Can retry setup token to update owner.${___X_CMD_UNSEENCHAR_NEWLINE}Or check your current token setting."
                return 1
            fi
        fi
        owner_repo="${___X_CMD_GH_CURRENT_owner}/${op}"
        ;;
    esac
}

___x_cmd_gh_default() {
    param_default "$@" 2>/dev/null || return 1
}

_____x_cmd_git_branch() {
    git symbolic-ref -q --short HEAD 2>/dev/null
}
# EndSection

# Section: Advise
_____x_cmd_gh_advise() {
    _____x_cmd_gh_advise_parse "$@" | x jo .\* .login | x ja '{printf("%s ", $0)}'
}

_____x_cmd_gh_advise_parse() {
    local op="$1"
    case "$op" in
        orgls) x ccmd 1d -- x gh org ls 2>/dev/null;;
    esac
}
# EndSection
