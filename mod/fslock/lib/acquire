# shellcheck shell=dash

# fingerprint
# pid
# fingerprint
# name/type
# user info

___x_cmd_fslock_acquire(){
    local fslock_name="$1"

    local x_=;  ___x_cmd_pidofsubshell_

    x mkdirp "$___X_CMD_FSLOCK_ROOT"
    local fslock_fp="${___X_CMD_FSLOCK_ROOT}/${fslock_name}.fslock.x-cmd.X"
    local fslock_fp_pid="${___X_CMD_FSLOCK_ROOT}/${fslock_name}.fslock.x-cmd.$x_"

    fslock:info --name "$fslock_name" --spid "$x_" "acquire fslock[$fslock_name]"

    {
        printf "%s\n" "$x_"
        x ps fingerprint get "$x_"
        printf "%s\n" "$fslock_name"
    } >"${fslock_fp_pid}" 2>/dev/null || {
        [ ! -f "$fslock_fp_pid" ] || ___x_cmd_cmds_rm "${fslock_fp_pid}"
        return 1
    }

    ___x_cmd_cmds_ln -s "${fslock_fp_pid}" "${fslock_fp}" 2>/dev/null || {
        ___x_cmd_cmds_rm "${fslock_fp_pid}"
        return 1
    }

    read -r pidline <"$fslock_fp"
    [ "$pidline" = "$x_" ] || {
        fslock:warn --spid "$x_" "This should be bug in MSYS. fslock[$fslock_name] is acquired by other process[$pidline]"
        [ ! -f "$fslock_fp_pid" ] || ___x_cmd_cmds_rm "${fslock_fp_pid}"
        return 1
    }
}
