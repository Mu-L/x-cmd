# shellcheck shell=dash

___x_cmd_xx___co_fix_(){
    local _stderrfp=
    local _cmdstr=

    local op="$1";  shift
    case "$op" in
        --cmdstr)       _stderrfp="$1";     _cmdstr="$2"; shift ;;
        --cmdarr)       _stderrfp="$1";
                        shift 1
                        x cmdstr _cmdstr "$@"
                        ;;
        *)              N=xx M="Not support such subcmd[$op]" log:ret:64
                        ;;
    esac

    [ -n "$_cmdstr" ] || {
        xx:error "The shell command to fix is null"
        return 1
    }

    # provide command version
    # provide os version
    # provide help info ...

    # RERUN_RESULT

    # provide more ...
    x_=; x rat_ "$_stderrfp" || return
    local _rerun_result="$x_"

    x os name_  || return
    local prompt="
You are a shell command fixer and the current shell in the environment is $___X_CMD_SHELL and the operating system is $x_.
Your output MUST ONLY be the shell code ready to run. No extra.
You MUST ALWAYS follow them as the example above. NO exceptions.

For Example: sudo apt instbll vim
sudo apt install vim

For Example: apk aad vim
sudo apk add vim

The shell command to fix is : $_cmdstr

---
FYI, the command error output is as below:
$_rerun_result
"

    x_="$(x chat --request --with-type-prompt "xx" "$prompt" "$@")" || return
    xx:debug "AI fix [$x_]"
}

# ___x_cmd_xx___arg2cmdstr_(){
#     local data=
#     while [ $# -gt 0 ]; do
#         ___x_cmd_q1_ "$1"
#         data="$data $x_"
#     done
#     x_="$data"
# }
