# shellcheck shell=dash

# using rerun to fix
___x_cmd_xx___fix___rerun(){
    local x_=""
    if [ $# -eq 0 ]; then
        x_=; x history --last_ || return
        local x_id="${x_%% *}"
        local x_cmd="${x_#* }"
        x_=; ___x_cmd_xx___fix___rerun___cmdstr_ "$x_id" "$x_cmd" || return
    else
        local fake_id="CMDARR.${HISTCMD}"
        x_=; ___x_cmd_xx___fix___rerun___cmdarr_ "$fake_id" "$@" || return
    fi

    local ___X_CMD_XX_FIX_CHOICELIST="${___X_CMD_XX_FIX_CHOICELIST}${___X_CMD_UNSEENCHAR_NEWLINE}${x_}"
    ___x_cmd_xx___execchoicelist "$___X_CMD_XX_FIX_CHOICELIST"
}


___x_cmd_xx___fix___rerun___cmdarr_(){
    local _cmdid="$1"; shift
    x ui yesno "Use ai to fix, or exit" || return
    x_=; ___x_cmd_xx___fix___rerun_cmdresult_ --cmdarr "$_cmdid" "$@" || return
    ___x_cmd_xx___co_fix_ --cmdarr "$x_" "$@"
}

___x_cmd_xx___fix___rerun___cmdstr_(){
    local _cmdid="$1"
    local _cmdstr="$2"
    x ui yesno "Use ai to fix, or exit" || return
    x_=; ___x_cmd_xx___fix___rerun_cmdresult_ --cmdstr "$_cmdid" "$_cmdstr" || return
    ___x_cmd_xx___co_fix_ --cmdstr "$x_" "$_cmdstr"
}


___x_cmd_xx___fix___rerun_cmdresult_(){
    local _cmdid=
    local _cmdstr=

    local op="$1";  shift
    case "$op" in
        --cmdstr)       _cmdid="$1";    _cmdstr="$2"; shift 2 ;;
        --cmdarr)       _cmdid="$1";    shift 1 ;;
        *)              N=xx M="Not support such subcmd[$op]" log:ret:64
                        ;;
    esac

    [ -n "$_cmdid" ] || N=xx M="Not found cmd id" log:ret:1
    x_="$___X_CMD_ROOT_TMP/xx/rerun/$$/$_cmdid"
    [ ! -f "$x_" ] || return 0
    xx:debug "Rerun cmd stderr result filepath[$x_]"
    x ensurefp "$x_"
    (
        {
            if [ -n "$_cmdstr" ]; then
                eval "$_cmdstr"
            else
                "$@"
            fi
        } 2>"$x_"
    )
    return 0
}

