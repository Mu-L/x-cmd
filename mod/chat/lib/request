# shellcheck shell=dash

___x_cmd_chat_request(){
    local type="$1"; shift
    local system="$1"; shift

    local current_message;
    current_message="$( printf "%s\n" "$*" | x jo n | x jo t " " )"

    # default loading the last 3 history record as the context
    local x_=""; ___x_cmd_chat_cur get_ history;
    local message; message="$(
        {
            printf "[\n%s\n" "$system"
            ___x_cmd_chat_handler___get_history_record "$___X_CMD_CHAT_SESSION_DIR" "${x_:-3}"
            printf "%s\n]\n" "$current_message"
        } | x jo n | x jo t " "
    )"

    [ -z "$___X_CMD_CHAT_CONFIRM_BEFORE_SEND" ] || {
        printf "%s\n" "$current_message" | x j2y | x bat -l yml
        printf "%s\n" "Press Enter To Continue. Ctrl-C to Intterrupt" >&2
        local nullchar
        read -r nullchar || return
    }

    # Handle the output by increasing the index
    local outputfile="$___X_CMD_CHAT_TMP/output.$$"
    ___x_cmd_chat_request___api "$outputfile" "$type" "$message" "$current_message"

    case "$___X_CMD_CHAT_OUTPUT" in
        raw)        cat "$outputfile" ; return ;;
    esac

    if [ -t 1 ] && ___x_cmd_is_interative; then
        case "$type" in
            normal)     ___x_cmd_chat_handler___stream_to_print <"$outputfile" | x md show ;;
            json)       ___x_cmd_chat_handler___stream_to_print <"$outputfile" | x jo color ;;
            *)          ___x_cmd_chat_handler___stream_to_print <"$outputfile" ;;
        esac
    else
        # Just Using tail
        ___x_cmd_chat_handler___stream_to_print <"$outputfile"
    fi
}

# 1000 => cluster into a xz file
___x_cmd_chat_request___api(){(
    local output="$1"
    local type="$2"         # Shoud be a quoted json string
    local message="$3"     # Shoud be a quoted json string
    shift 3
    local IFS=" ";  local current_message="$*"
    local filepath; filepath="$___X_CMD_CHAT_SESSION_DIR/$(x pidid vlseqid ___X_CMD_CHAT_REC).jso"

    x rmrf "$output"    # Using
    mkfifo "$output"
    (
        # shellcheck disable=SC3044
        [ -z "$BASH_VERSION" ] || shopt -s expand_aliases
        x ensurefp "$filepath"
        chat:debug "Sending request $output => $message"
        local resp=""; resp="$(___x_cmd_chat_request___api_ "$message" | tee "$output" | ___x_cmd_chat_handler___get_response )"
        chat:debug "Saving => $filepath"

        # TODO: Use pure json instead of yml.
        {
            printf "%s\n" '{
                type: "'"$type"'",
                current_message: '"${current_message:-"\"\""}"',
                message: '"${message:-"\"\""}"',
                response: '"${resp:-"\"\""}"'
            }' | x jo n
        } >>"$filepath"

        x rmrf "$output"
    ) &
)}

# Using chatgpt api
# ref: https://platform.openai.com/docs/api-reference/chat/create
___x_cmd_chat_request___api_(){
    local message="$1"
    local x_

    local apikey;   local proxy;    local maxtoken
    ___x_cmd_chat_cur apikey:= proxy:= maxtoken:=

    [ -n "$apikey" ] || {
        chat:error "Please setting up your apikey first ==> 'x chat cfg apikey=<your apikey>' or 'x chat apikey=<your apikey>'"
        return 1
    }

    # default maxtoken 1000
    maxtoken="${maxtoken:-1000}"
    local data='{
        "model": "gpt-3.5-turbo",
        "messages": '"$message"',
        "temperature": 0.7,
        "max_tokens": '$maxtoken',
        "stream": true
    }'

    chat:debug "data ==> $data"

    # TODO: Need to json quote the content
    # LANG=en_US.UTF-8 LC_ALL=en_US.UTF-8
    x curl \
        ${proxy:+-x} ${proxy:+"$proxy"}                 \
        -sS https://api.openai.com/v1/chat/completions  \
        -H "Content-Type: application/json"             \
        -H "Authorization: Bearer $apikey"              \
        -d "$data" # | tee result.json

    chat:debug x curl \
        ${proxy:+-x} ${proxy:+"$proxy"}                 \
        https://api.openai.com/v1/chat/completions      \
        -H "Content-Type: application/json"             \
        -H "Authorization: Bearer $apikey"              \
        -d "$data"
}
