# shellcheck shell=dash


___x_cmd_co_exec(){
    case "$1" in
        -h|--help) ___x_cmd help -m co --exec; return 0 ;;
    esac

    local data
    data="$(___x_cmd_co_exec_ "$@")" || return
    [ -n "$data" ] || return
    # Just preserve the json data which only asked
    data="${data#*\{}"
    data="${data%\}*}"
    data="{$data}"
    ___x_cmd_co_exec_app2 "$data"
}

___x_cmd_co_exec_(){
    local LOCALSHELL=
    local OS=

    local x_=""
    x os name_

    LOCALSHELL="$___X_CMD_SHELL" OS="$x_" ___x_cmd chat --send --type "co" --minion "$___X_CMD_ROOT_MOD/co/lib/minion/multi.yml" "$@"
}

___x_cmd_co_exec_app1(){
    local data="$1"
    data="$( printf "%s\n" "$data" | ___x_cmd jo .answer | ___x_cmd jo 2c .cmd .desc )"
    [ -n "$data" ] || N=co M="Response data format error or empty" log:ret:1

    local ___X_CMD_CSV_APP_DATA_Command=
    local ___X_CMD_CSV_APP_DATA_Description=
    ___x_cmd csv app --header Command,Description --return var <<A
$data
A
    [ -n "$___X_CMD_CSV_APP_DATA_Command" ] || return
    co:info --desc "$___X_CMD_CSV_APP_DATA_Description" --cmd "$___X_CMD_CSV_APP_DATA_Command"
    ___x_cmd ui yesno "Do your want to execute the above command ?" || return
    eval "$___X_CMD_CSV_APP_DATA_Command"
}

___x_cmd_co_exec_app2(){
    local data="$1"
    printf "%s\n" "$data" | ___x_cmd j2y >/dev/tty || N=co M="Response data format error or empty" log:ret:1

    local _cmd=
    local _selectcmd=
    _selectcmd="$( printf "%s\n" "$data" | ___x_cmd jo '.answer.*' .cmd | ___x_cmd cawk -f "$___X_CMD_ROOT_MOD/co/lib/awk/gen_exec_uiselect.awk" )" || return
    # printf "%s\n" ""
    x ui sep
    eval "$_selectcmd" || return
    [ -n "$_cmd" ] || return
    eval "$_cmd"


    # printf "%s\n" "$data" | x jo .answer.\* .cmd | x pick
}

