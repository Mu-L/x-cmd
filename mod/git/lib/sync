
___x_cmd_git_sync(){
    local op="$1"; shift
    case "$op" in
        track|pull|push|run)    ___x_cmd_git_sync_"$op" "$@" ;;
        *)                      ___x_cmd_git_sync_run "$op" "$@" ;;
    esac
}

___x_cmd_git_sync_run(){
    local ORIGIN=origin
    while true; do
        case "$1" in
            --src)      ORIGIN="$2"; shift 2 ;;
            *)          break
        esac
    done

    if [ "$#" -eq 0 ]; then
        git:error "Please provide at least one remote name or url."
        return 1
    fi

    ___x_cmd_git_sync_track "$ORIGIN"
    ___x_cmd_git_sync_pull "$ORIGIN" && \
    ___x_cmd_git_sync_push "$@"
}

# Actuall, we would better jsut track on source.
___x_cmd_git_sync_track(){
    local name="${1:-origin}"
    ___x_cmd___git_trackall "$name"
}

___x_cmd_git_sync_pull(){
    [ "$#" -ne 0 ] || set -- origin

    for name in "$@"; do
        ___x_cmd___git_origin fetch "$name"
        ___x_cmd___git_origin pull "$name"
    done
}

___x_cmd_git_sync_push(){
    # ! ___x_cmd_git_is_empty || {
    #     git:warn "___x_cmd_git_sync_push abort: Git directory is empty."
    #     return 1
    # }

    local name; for name in "$@"; do
        ___x_cmd_git_sync_push___one "$name";
    done
}

___x_cmd_git_sync_push___one(){
    local name="${1:?Provide name or url}"

    if ! ___x_cmd___git_origin push -u "$name" --all; then
        x:warn "Push In Force: git push -u -f $name --all"
        ___x_cmd___git_origin push -u -f "$name" --all
    fi

    if ! ___x_cmd___git_origin push -u "$name" --tags; then
        x:warn "Push In Force: git push -u -f $name --tags"
        ___x_cmd___git_origin push -u -f "$name" --tags
    fi
}
